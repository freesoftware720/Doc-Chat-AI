-- Drop existing policies if they exist to avoid conflicts, then recreate them.
DROP POLICY IF EXISTS "Allow authenticated users to read active gateways" ON public.payment_gateways;
DROP POLICY IF EXISTS "Allow full access for service_role" ON public.payment_gateways;
DROP TABLE IF EXISTS public.payment_gateways;

-- Create the payment_gateways table
CREATE TABLE IF NOT EXISTS public.payment_gateways (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    icon_url TEXT,
    instructions TEXT NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS policies for payment_gateways
ALTER TABLE public.payment_gateways ENABLE ROW LEVEL SECURITY;

-- Allow authenticated users to read active gateways
CREATE POLICY "Allow authenticated users to read active gateways"
ON public.payment_gateways
FOR SELECT
TO authenticated
USING (is_active = TRUE);

-- Allow service_role to do everything (for admin panel)
CREATE POLICY "Allow full access for service_role"
ON public.payment_gateways
FOR ALL
TO service_role
USING (true)
WITH CHECK (true);


-- Drop existing policies on workspaces if they exist
DROP POLICY IF EXISTS "Enable read access for workspace members" ON public.workspaces;
DROP POLICY IF EXISTS "Enable full access for workspace owners" ON public.workspaces;

-- Ensure id is primary key and remove duplicates
ALTER TABLE public.workspaces DROP CONSTRAINT IF EXISTS workspaces_pkey;
ALTER TABLE public.workspaces ADD PRIMARY KEY (id);

-- Create a custom type for workspace roles if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workspace_role') THEN
        CREATE TYPE public.workspace_role AS ENUM ('admin', 'member');
    END IF;
END$$;


-- App Settings Table
CREATE TABLE IF NOT EXISTS public.app_settings (
    id BIGINT PRIMARY KEY,
    chat_limit_free_user INT NOT NULL DEFAULT 50,
    feature_chat_templates_enabled BOOLEAN NOT NULL DEFAULT true,
    feature_multi_pdf_enabled BOOLEAN NOT NULL DEFAULT false,
    homepage_announcement_message TEXT,
    logo_url TEXT,
    landing_page_content JSONB,
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE public.app_settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable read access for all users" ON public.app_settings FOR SELECT USING (true);
CREATE POLICY "Enable full access for service_role" ON public.app_settings FOR ALL TO service_role USING (true) WITH CHECK (true);


-- Workspaces Table
CREATE TABLE IF NOT EXISTS public.workspaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    owner_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    logo_url TEXT,
    brand_color TEXT,
    max_documents INT NOT NULL DEFAULT 10,
    allowed_file_types TEXT[]
);
ALTER TABLE public.workspaces ENABLE ROW LEVEL SECURITY;

-- Workspace Members Table
CREATE TABLE IF NOT EXISTS public.workspace_members (
    workspace_id UUID NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role public.workspace_role NOT NULL DEFAULT 'member',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (workspace_id, user_id)
);
ALTER TABLE public.workspace_members ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Enable read access for workspace members" ON public.workspace_members;
CREATE POLICY "Enable read access for workspace members" ON public.workspace_members FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.workspace_members
    WHERE workspace_id = workspace_members.workspace_id AND user_id = auth.uid()
  )
);


-- Profiles Table
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    avatar_url TEXT,
    subscription_plan TEXT,
    active_workspace_id UUID REFERENCES public.workspaces(id) ON DELETE SET NULL,
    referral_code TEXT UNIQUE,
    referred_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    pro_credits INT DEFAULT 0,
    status TEXT DEFAULT 'active', -- e.g., 'active', 'banned'
    ban_reason TEXT,
    banned_at TIMESTAMPTZ,
    chat_credits_used INT NOT NULL DEFAULT 0,
    chat_credits_last_reset TIMESTAMPTZ
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable read access for own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Enable update access for own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Referrals Table
CREATE TABLE IF NOT EXISTS public.referrals (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    referrer_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    referred_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
ALTER TABLE public.referrals ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable read access for involved users" ON public.referrals FOR SELECT USING (auth.uid() = referrer_id OR auth.uid() = referred_id);


-- Documents Table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    storage_path TEXT NOT NULL,
    content TEXT,
    file_size INT
);
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable access for document owner" ON public.documents FOR ALL USING (auth.uid() = user_id);

-- Messages Table
CREATE TABLE IF NOT EXISTS public.messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    document_id UUID NOT NULL REFERENCES public.documents(id) ON DELETE CASCADE,
    role TEXT NOT NULL, -- 'user' or 'assistant'
    content TEXT NOT NULL
);
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable access for message owner" ON public.messages FOR ALL USING (auth.uid() = user_id);

-- Audit Logs Table
CREATE TABLE IF NOT EXISTS public.audit_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  workspace_id UUID NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  user_email TEXT,
  action TEXT NOT NULL,
  details JSONB
);
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;
-- RLS for audit_logs: Only workspace admins can see their workspace logs.
CREATE POLICY "Enable read for workspace admins" ON public.audit_logs FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.workspace_members
    WHERE workspace_id = audit_logs.workspace_id AND user_id = auth.uid() AND role = 'admin'
  )
);


-- Function to generate a unique referral code
CREATE OR REPLACE FUNCTION public.generate_referral_code()
RETURNS TEXT AS $$
DECLARE
    new_code TEXT;
    is_duplicate BOOLEAN;
BEGIN
    LOOP
        new_code := (
            SELECT string_agg(
                (
                    SELECT substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', floor(random() * 36)::int + 1, 1)
                ), ''
            )
            FROM generate_series(1, 8)
        );
        SELECT EXISTS (
            SELECT 1 FROM public.profiles WHERE referral_code = new_code
        ) INTO is_duplicate;

        IF NOT is_duplicate THEN
            RETURN new_code;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Function to create a user profile and default workspace on new user sign-up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
    new_workspace_id UUID;
BEGIN
    -- Create profile
    INSERT INTO public.profiles (id, full_name, avatar_url, referral_code)
    VALUES (
        new.id,
        new.raw_user_meta_data->>'full_name',
        new.raw_user_meta_data->>'avatar_url',
        public.generate_referral_code()
    );

    -- Create personal workspace for the user
    INSERT INTO public.workspaces (owner_id, name)
    VALUES (new.id, new.raw_user_meta_data->>'full_name' || '''s Workspace')
    RETURNING id INTO new_workspace_id;

    -- Make user an admin of their new workspace
    INSERT INTO public.workspace_members (workspace_id, user_id, role)
    VALUES (new_workspace_id, new.id, 'admin');
    
    -- Set the new workspace as active
    UPDATE public.profiles
    SET active_workspace_id = new_workspace_id
    WHERE id = new.id;

    RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for new user
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- Function to get a user's chat history
CREATE OR REPLACE FUNCTION public.get_user_chat_history()
RETURNS TABLE (
  document_id UUID,
  document_name TEXT,
  last_message_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  WITH last_message AS (
    SELECT
      m.document_id,
      MAX(m.created_at) as max_created_at
    FROM public.messages m
    WHERE m.user_id = auth.uid()
    GROUP BY m.document_id
  )
  SELECT
    d.id as document_id,
    d.name as document_name,
    lm.max_created_at as last_message_at
  FROM public.documents d
  JOIN last_message lm ON d.id = lm.document_id
  WHERE d.user_id = auth.uid()
  ORDER BY lm.max_created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- Storage Setup: Create a bucket for documents with public read access
-- Note: Run this part manually if you prefer more granular control.
-- This makes document URLs publicly accessible, which is required for the PDF viewer.
INSERT INTO storage.buckets (id, name, public)
VALUES ('documents', 'documents', true)
ON CONFLICT (id) DO UPDATE SET public = true;

-- Policies for storage bucket
DROP POLICY IF EXISTS "Enable insert for authenticated users" ON storage.objects;
CREATE POLICY "Enable insert for authenticated users"
ON storage.objects FOR INSERT TO authenticated
WITH CHECK (bucket_id = 'documents');

DROP POLICY IF EXISTS "Enable update for authenticated users" ON storage.objects;
CREATE POLICY "Enable update for authenticated users"
ON storage.objects FOR UPDATE TO authenticated
USING (auth.uid() = owner);

DROP POLICY IF EXISTS "Enable delete for authenticated users" ON storage.objects;
CREATE POLICY "Enable delete for authenticated users"
ON storage.objects FOR DELETE TO authenticated
USING (auth.uid() = owner);

DROP POLICY IF EXISTS "Enable read access for all users" ON storage.objects;
CREATE POLICY "Enable read access for all users"
ON storage.objects FOR SELECT
USING (bucket_id = 'documents');

-- Initial App Settings
INSERT INTO public.app_settings (id, landing_page_content)
VALUES (
    1,
    '{
        "hero": {
            "headline_part_1": "Chat with your",
            "headline_animated_texts": ["documents", "reports", "manuals", "textbooks"],
            "headline_part_2": "using AI",
            "subheadline": "Upload a PDF and get instant answers to your questions with the power of AI.",
            "cta_button": "Upload PDF",
            "cta_secondary": "No credit card required"
        },
        "features": {
            "headline": "A Smarter Way to Work With Documents",
            "subheadline": "Doc-Chat AI transforms your static documents into dynamic conversational partners.",
            "items": [
                { "icon": "UploadCloud", "title": "Seamless PDF Upload", "description": "Drag and drop any PDF to get started. Your documents are processed quickly and securely." },
                { "icon": "Sparkles", "title": "Intelligent AI-Powered Q&A", "description": "Ask complex questions and receive accurate, context-aware answers in seconds." },
                { "icon": "ShieldCheck", "title": "Secure & Private by Design", "description": "Your data is encrypted and confidential. Chat with your documents with complete peace of mind." }
            ]
        },
        "pricing": {
            "headline": "Choose the Plan That''s Right for You",
            "subheadline": "Simple, transparent pricing. No hidden fees.",
            "plans": [
                { "name": "Free", "price": "$0", "period": "/ month", "description": "For individuals and small projects to get a taste of AI power.", "features": ["3 PDF uploads / month", "50 questions / month", "2MB file size limit", "Community support"], "cta": "Start for Free", "link": "/auth/register", "isPopular": false },
                { "name": "Pro", "price": "$19", "period": "/ month", "description": "For professionals and teams who need unlimited power.", "features": ["Unlimited PDF uploads", "Unlimited questions", "32MB file size limit", "Priority email support", "Advanced AI models"], "cta": "Go Pro", "link": "/auth/register", "isPopular": true }
            ]
        },
        "faq": {
            "headline": "Frequently Asked Questions",
            "subheadline": "Have questions? We''ve got answers. If you can''t find what you''re looking for, feel free to contact us.",
            "items": [
                { "question": "How does Doc-Chat AI work?", "answer": "Doc-Chat AI uses advanced large language models to analyze the content of your PDF documents. Once you upload a file, our AI reads and understands the text, allowing you to ask questions and receive intelligent, context-aware answers in a conversational format." },
                { "question": "Is my data secure?", "answer": "Yes, security is our top priority. All documents are encrypted in transit and at rest. We do not use your data for training our models. You have full control over your documents and can delete them from our servers at any time." },
                { "question": "What kind of documents can I upload?", "answer": "Currently, we support PDF documents. We are working on expanding our capabilities to include other formats like DOCX, TXT, and more in the near future. The maximum file size depends on your subscription plan." },
                { "question": "Can I cancel my subscription anytime?", "answer": "Absolutely. You can manage your subscription from your account settings. If you cancel, you will retain access to your plan''s features until the end of the current billing cycle. There are no cancellation fees." }
            ]
        },
        "legal_pages": {
            "privacy": { "title": "Privacy Policy", "content": "This is the default privacy policy. Please update this content from the Super Admin settings." },
            "terms": { "title": "Terms of Service", "content": "These are the default terms of service. Please update this content from the Super Admin settings." },
            "about": { "title": "About Us", "content": "This is the default about us page. Please update this content from the Super Admin settings." },
            "contact": { "title": "Contact Us", "content": "This is the default contact page. Please update this content from the Super Admin settings." }
        }
    }'
) ON CONFLICT (id) DO NOTHING;
