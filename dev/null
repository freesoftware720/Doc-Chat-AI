-- 1. Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;

-- 2. Create Plans Table
CREATE TABLE IF NOT EXISTS public.plans (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    price NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    currency TEXT NOT NULL DEFAULT 'USD',
    currency_symbol TEXT NOT NULL DEFAULT '$',
    period TEXT DEFAULT '/ month',
    features TEXT[] NOT NULL DEFAULT '{}',
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    is_popular BOOLEAN NOT NULL DEFAULT FALSE,
    type TEXT NOT NULL DEFAULT 'individual' CHECK (type IN ('individual', 'team'))
);
COMMENT ON TABLE public.plans IS 'Stores billing plans for the application.';
-- Add foreign key constraint from profiles to plans if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'profiles_subscription_plan_fkey'
    ) THEN
        -- Before adding the constraint, update any non-matching values in profiles
        UPDATE public.profiles
        SET subscription_plan = 'Basic'
        WHERE subscription_plan IS NOT NULL AND subscription_plan NOT IN (SELECT name FROM public.plans);

        -- Add 'Basic' and 'Student' plans if they don't exist to satisfy the FK
        INSERT INTO public.plans (name, description, price, features, type) 
        VALUES ('Basic', 'The essential features to get you started.', 0, ARRAY['5 MB File Upload Limit', '50 Messages per Day', 'Basic AI Model'], 'individual') 
        ON CONFLICT (name) DO NOTHING;
        
        INSERT INTO public.plans (name, description, price, features, type) 
        VALUES ('Student', 'Advanced tools for learning and research.', 0, ARRAY['100 MB File Upload Limit', 'Unlimited Messages', 'Advanced AI Tools'], 'individual')
        ON CONFLICT (name) DO NOTHING;
        
        ALTER TABLE public.profiles
        ADD CONSTRAINT profiles_subscription_plan_fkey
        FOREIGN KEY (subscription_plan) REFERENCES public.plans(name) ON DELETE SET DEFAULT ON UPDATE CASCADE;
    END IF;
END;
$$;


-- 3. Create Payment Gateways Table
CREATE TABLE IF NOT EXISTS public.payment_gateways (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    name TEXT NOT NULL UNIQUE,
    instructions TEXT NOT NULL,
    icon_url TEXT,
    is_active BOOLEAN NOT NULL DEFAULT TRUE
);
COMMENT ON TABLE public.payment_gateways IS 'Stores custom payment gateway information.';

-- 4. Create Profiles Table
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    avatar_url TEXT,
    subscription_plan TEXT DEFAULT 'Basic',
    status TEXT DEFAULT 'active' CHECK (status IN ('active', 'banned')),
    ban_reason TEXT,
    banned_at TIMESTAMPTZ,
    chat_credits_used INTEGER NOT NULL DEFAULT 0,
    chat_credits_last_reset TIMESTAMPTZ DEFAULT NOW(),
    last_daily_reward_claimed_at TIMESTAMPTZ,
    referral_code TEXT UNIQUE,
    referred_by UUID REFERENCES public.profiles(id),
    pro_credits INTEGER DEFAULT 0
);
COMMENT ON TABLE public.profiles IS 'Stores public profile data for each user.';
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- 5. Function to generate a unique referral code
CREATE OR REPLACE FUNCTION public.generate_referral_code()
RETURNS TEXT AS $$
DECLARE
    new_code TEXT;
    is_unique BOOLEAN;
BEGIN
    LOOP
        new_code := (
            SELECT string_agg(
                (
                    SELECT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
                )::TEXT
                , ''
            )
            FROM (
                SELECT (
                    SELECT SUBSTRING(
                        'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
                        , (random() * 61)::integer + 1, 1
                    )
                )
                FROM generate_series(1, 8)
            ) AS a
        );
        SELECT NOT EXISTS (SELECT 1 FROM public.profiles WHERE referral_code = new_code) INTO is_unique;
        IF is_unique THEN
            RETURN new_code;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 6. Function to handle new user setup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.profiles (id, full_name, avatar_url, referral_code)
    VALUES (
        new.id,
        new.raw_user_meta_data->>'full_name',
        new.raw_user_meta_data->>'avatar_url',
        public.generate_referral_code()
    );
    RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Drop trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
-- Create trigger
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 7. Create Documents Table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    content TEXT,
    storage_path TEXT NOT NULL,
    file_size INTEGER,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE public.documents IS 'Stores metadata for uploaded documents.';
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own documents." ON public.documents;
CREATE POLICY "Users can view their own documents." ON public.documents FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can insert their own documents." ON public.documents;
CREATE POLICY "Users can insert their own documents." ON public.documents FOR INSERT WITH CHECK (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can delete their own documents." ON public.documents;
CREATE POLICY "Users can delete their own documents." ON public.documents FOR DELETE USING (auth.uid() = user_id);

-- 8. Create Messages Table
CREATE TABLE IF NOT EXISTS public.messages (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    document_id UUID NOT NULL REFERENCES public.documents(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE public.messages IS 'Stores chat messages for each document.';
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own messages." ON public.messages;
CREATE POLICY "Users can view their own messages." ON public.messages FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can insert their own messages." ON public.messages;
CREATE POLICY "Users can insert their own messages." ON public.messages FOR INSERT WITH CHECK (auth.uid() = user_id);

-- 9. Create Subscription Requests Table
CREATE TABLE IF NOT EXISTS public.subscription_requests (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    plan_id BIGINT NOT NULL REFERENCES public.plans(id) ON DELETE RESTRICT,
    payment_gateway_id BIGINT NOT NULL REFERENCES public.payment_gateways(id) ON DELETE RESTRICT,
    transaction_id TEXT NOT NULL,
    receipt_url TEXT,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
    rejection_reason TEXT,
    reviewed_by UUID REFERENCES auth.users(id),
    reviewed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE public.subscription_requests IS 'Stores user subscription requests for manual review.';
ALTER TABLE public.subscription_requests ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own subscription requests." ON public.subscription_requests;
CREATE POLICY "Users can view their own subscription requests." ON public.subscription_requests FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can create subscription requests." ON public.subscription_requests;
CREATE POLICY "Users can create subscription requests." ON public.subscription_requests FOR INSERT WITH CHECK (auth.uid() = user_id);
-- Add receipt_url column if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name='subscription_requests' AND column_name='receipt_url'
    ) THEN
        ALTER TABLE public.subscription_requests ADD COLUMN receipt_url TEXT;
    END IF;
END;
$$;


-- 10. Create Referrals Table
CREATE TABLE IF NOT EXISTS public.referrals (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    referrer_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    referred_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(referrer_id, referred_id)
);
COMMENT ON TABLE public.referrals IS 'Tracks successful user referrals.';

-- 11. Create Reviews Table
CREATE TABLE IF NOT EXISTS public.reviews (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE UNIQUE,
    rating INT NOT NULL CHECK (rating >= 1 AND rating <= 5),
    content TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ
);
COMMENT ON TABLE public.reviews IS 'Stores user reviews of the application.';
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Reviews are public." ON public.reviews;
CREATE POLICY "Reviews are public." ON public.reviews FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can submit or update their own review." ON public.reviews;
CREATE POLICY "Users can submit or update their own review." ON public.reviews FOR ALL USING (auth.uid() = user_id);

-- 12. Create Support Tickets Table
CREATE TABLE IF NOT EXISTS public.support_tickets (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    subject TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'open' CHECK (status IN ('open', 'in_progress', 'closed')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE public.support_tickets IS 'Stores user support tickets.';
ALTER TABLE public.support_tickets ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view and manage their own support tickets." ON public.support_tickets;
CREATE POLICY "Users can view and manage their own support tickets." ON public.support_tickets FOR ALL USING (auth.uid() = user_id);

-- 13. Create Support Messages Table
CREATE TABLE IF NOT EXISTS public.support_messages (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ticket_id UUID NOT NULL REFERENCES public.support_tickets(id) ON DELETE CASCADE,
    sender_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    sender_role TEXT NOT NULL DEFAULT 'user' CHECK (sender_role IN ('user', 'admin')),
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE public.support_messages IS 'Stores messages within a support ticket.';
ALTER TABLE public.support_messages ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view messages for their own tickets." ON public.support_messages;
CREATE POLICY "Users can view messages for their own tickets." ON public.support_messages FOR SELECT USING (
    ticket_id IN (SELECT id FROM public.support_tickets WHERE user_id = auth.uid())
);
DROP POLICY IF EXISTS "Users can send messages in their own tickets." ON public.support_messages;
CREATE POLICY "Users can send messages in their own tickets." ON public.support_messages FOR INSERT WITH CHECK (
    sender_id = auth.uid() AND sender_role = 'user' AND ticket_id IN (SELECT id FROM public.support_tickets WHERE user_id = auth.uid() AND status <> 'closed')
);

-- 14. Function and Trigger to update ticket timestamp on new message
CREATE OR REPLACE FUNCTION public.update_ticket_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public.support_tickets
    SET updated_at = NOW()
    WHERE id = NEW.ticket_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
DROP TRIGGER IF EXISTS on_new_support_message ON public.support_messages;
CREATE TRIGGER on_new_support_message
    AFTER INSERT ON public.support_messages
    FOR EACH ROW EXECUTE FUNCTION public.update_ticket_updated_at();

-- 15. Create App Settings Table (Singleton)
CREATE TABLE IF NOT EXISTS public.app_settings (
    id INT PRIMARY KEY CHECK (id = 1),
    logo_url TEXT,
    homepage_announcement_message TEXT,
    chat_limit_free_user INT NOT NULL DEFAULT 50,
    upload_limit_mb_free INT NOT NULL DEFAULT 5,
    upload_limit_mb_pro INT NOT NULL DEFAULT 100,
    feature_chat_templates_enabled BOOLEAN NOT NULL DEFAULT TRUE,
    feature_multi_pdf_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    feature_video_ads_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    video_ad_code TEXT,
    video_ad_skip_timer INT NOT NULL DEFAULT 5,
    feature_banner_ads_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    banner_ad_code TEXT,
    feature_multiplex_ads_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    multiplex_ad_code TEXT,
    feature_in_feed_ads_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    in_feed_ad_code TEXT,
    feature_daily_reward_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    daily_reward_link TEXT,
    daily_reward_clicks_required INT NOT NULL DEFAULT 10,
    subscription_review_hours INT NOT NULL DEFAULT 24,
    landing_page_content JSON,
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
COMMENT ON TABLE public.app_settings IS 'Stores global application settings as a singleton row.';
-- Ensure row is singleton
CREATE UNIQUE INDEX IF NOT EXISTS app_settings_singleton ON public.app_settings ((id));

-- 16. Function to get user chat history
CREATE OR REPLACE FUNCTION public.get_user_chat_history()
RETURNS TABLE(document_id UUID, document_name TEXT, last_message_at TIMESTAMPTZ) AS $$
BEGIN
    RETURN QUERY
    WITH latest_messages AS (
        SELECT
            m.document_id,
            d.name as doc_name,
            m.created_at,
            ROW_NUMBER() OVER(PARTITION BY m.document_id ORDER BY m.created_at DESC) as rn
        FROM
            public.messages m
        JOIN
            public.documents d ON m.document_id = d.id
        WHERE
            m.user_id = auth.uid()
    )
    SELECT
        lm.document_id,
        lm.doc_name,
        lm.created_at
    FROM
        latest_messages lm
    WHERE
        lm.rn = 1
    ORDER BY
        lm.created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- 17. Storage: Create buckets & Update MIME types
-- Use ON CONFLICT DO NOTHING to avoid errors on re-run
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) 
VALUES ('documents', 'documents', false, 52428800, ARRAY['application/pdf','text/plain','application/vnd.openxmlformats-officedocument.wordprocessingml.document','application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/msword', 'application/vnd.ms-excel'])
ON CONFLICT (id) DO UPDATE SET allowed_mime_types = ARRAY['application/pdf','text/plain','application/vnd.openxmlformats-officedocument.wordprocessingml.document','application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/msword', 'application/vnd.ms-excel'];

INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) 
VALUES ('avatars', 'avatars', true, 1048576, ARRAY['image/png', 'image/jpeg']) ON CONFLICT (id) DO NOTHING;

INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) 
VALUES ('receipts', 'receipts', true, 5242880, ARRAY['image/png', 'image/jpeg', 'image/gif']) ON CONFLICT (id) DO NOTHING;

INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) 
VALUES ('gateway-icons', 'gateway-icons', true, 524288, ARRAY['image/png', 'image/jpeg', 'image/gif', 'image/svg+xml']) ON CONFLICT (id) DO NOTHING;

-- 18. Storage Policies
-- Documents
DROP POLICY IF EXISTS "Users can upload documents." ON storage.objects;
CREATE POLICY "Users can upload documents." ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'documents' AND (storage.foldername(name))[1] = auth.uid()::text);
DROP POLICY IF EXISTS "Users can view their own documents." ON storage.objects;
CREATE POLICY "Users can view their own documents." ON storage.objects FOR SELECT TO authenticated USING (bucket_id = 'documents' AND (storage.foldername(name))[1] = auth.uid()::text);
DROP POLICY IF EXISTS "Users can delete their own documents." ON storage.objects;
CREATE POLICY "Users can delete their own documents." ON storage.objects FOR DELETE TO authenticated USING (bucket_id = 'documents' AND (storage.foldername(name))[1] = auth.uid()::text);

-- Avatars
DROP POLICY IF EXISTS "Users can upload their own avatar." ON storage.objects;
CREATE POLICY "Users can upload their own avatar." ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'avatars' AND (storage.foldername(name))[1] = auth.uid()::text);
DROP POLICY IF EXISTS "Users can update their own avatar." ON storage.objects;
CREATE POLICY "Users can update their own avatar." ON storage.objects FOR UPDATE TO authenticated USING (bucket_id = 'avatars' AND (storage.foldername(name))[1] = auth.uid()::text);
DROP POLICY IF EXISTS "Avatars are publicly viewable." ON storage.objects;
CREATE POLICY "Avatars are publicly viewable." ON storage.objects FOR SELECT USING (bucket_id = 'avatars');


-- Receipts
DROP POLICY IF EXISTS "Users can upload their own receipts." ON storage.objects;
CREATE POLICY "Users can upload their own receipts." ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'receipts' AND (storage.foldername(name))[1] = auth.uid()::text);
DROP POLICY IF EXISTS "Receipts are publicly viewable." ON storage.objects;
CREATE POLICY "Receipts are publicly viewable." ON storage.objects FOR SELECT USING (bucket_id = 'receipts');

-- Gateway Icons
DROP POLICY IF EXISTS "Admins can manage gateway icons." ON storage.objects;
CREATE POLICY "Admins can manage gateway icons." ON storage.objects FOR ALL USING (bucket_id = 'gateway-icons' AND (SELECT auth.role()) = 'service_role');
DROP POLICY IF EXISTS "Gateway icons are publicly viewable." ON storage.objects;
CREATE POLICY "Gateway icons are publicly viewable." ON storage.objects FOR SELECT USING (bucket_id = 'gateway-icons');
